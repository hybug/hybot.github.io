---
layout:     post
title:      关于LeetCode的一些关于递归方法的解答
subtitle:   算法
date:       2018-12-14
author:     Hybot
header-img: img/post-md.jpg
catalog: true
tags:
    - 算法
---

> 树是一种递归结构，很多树的问题可以使用递归来处理。

### 1.树的高度

[104\. Maximum Depth of Binary Tree (Easy)](https://leetcode.com/problems/maximum-depth-of-binary-tree/description/)

```
class Solution(object):
    def maxDepth(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        if not root:
            return 0
        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1
```

### 2.判断平衡树

[110\. Balanced Binary Tree (Easy)](https://leetcode.com/problems/balanced-binary-tree/description/)

判断左右子节点的深度差，大于1则为False

```
class Solution(object):
    def isBalanced(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        if not root:
            return True
        self.res = True
        self.helper(root)
        return self.res
        
    def helper(self, root):
        if not root:
            return 0
        l = self.maxDepth(root.left)
        r = self.maxDepth(root.right)
        if abs(l-r)>1:
            self.res = False
        self.helper(root.left)
        self.helper(root.right)
        
    def maxDepth(self, root):
        if not root:
            return 0
        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1
```

这种写法在树非常非常深的时候，会Time Limit Exceeded，主要耗时步骤就在maxDepth，我们并不需要得到所有子节点的深度，一旦深度差大于1，我们就可以return False了

```
class Solution(object):
    def isBalanced(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        if not root:
            return True
        self.res = True
        self.helper(root)
        return self.res
        
    def helper(self, root):
        if not root:
            return 0
        l = self.helper(root.left)
        r = self.helper(root.right)
        if abs(l-r)>1:
            self.res = False
        return max(l, r) + 1
```

### 3.树的直径求解

[543\. Diameter of Binary Tree (Easy)](https://leetcode.com/problems/diameter-of-binary-tree/description/)

root的直径 = root.left的深度 + root.right的深度

```
class Solution(object):
    def diameterOfBinaryTree(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        res = 0
        if not root:
            return res
        res = self.maxDepth(root.left) + self.maxDepth(root.right)
        return max(res, self.diameterOfBinaryTree(root.left), self.diameterOfBinaryTree(root.right))
        
    def maxDepth(self, root):
        if not root:
            return 0
        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1
```

发现这种方法非常耗时，和上一题一样，我们可以把对子节点深度的操作集成到maxDepth中去

在需要对子节点进行操作的问题中，我们一般把递归集成到maxDepth中，在maxDepth递归求解深度的过程中完成我们需要的答案求解。

```
class Solution(object):
    def diameterOfBinaryTree(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        self.res = 0
        if not root:
            return 0
        self.maxDepth(root)
        return self.res
        
    def maxDepth(self, root):
        if not root:
            return 0
        l = self.maxDepth(root.left)
        r = self.maxDepth(root.right)
        self.res = max(self.res, l+r)
        return max(l, r) + 1
```

### 4.翻转树操作

[226\. Invert Binary Tree (Easy)](https://leetcode.com/problems/invert-binary-tree/description/)

This problem was inspired by [this original twitter](https://twitter.com/mxcl/status/608682016205344768) by [Max Howell](https://twitter.com/mxcl):
> Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so fck off.

和树的深度求解一样简单的递归：(**弄明白递归函数的输入是什么，需要返回什么，什么时候跳出是写出递归的关键**)

left = root.left

root.left = root.right

root.right = left

变成递归模式，我们的left和right子节点也需要进行翻转操作

left = root.left

root.left = invert(root.right)

root.right = invert(left)


```
class Solution(object):
    def invertTree(self, root):
        """
        :type root: TreeNode
        :rtype: TreeNode
        """
        if not root:
            return None
        left = root.left
        root.left = self.invertTree(root.right)
        root.right = self.invertTree(left)
        return root
```

### 5.归并两颗树

[617\. Merge Two Binary Trees (Easy)](https://leetcode.com/problems/merge-two-binary-trees/description/)

归并排序会不会？不会赶快去复习复习十大排序算法，虽然这题解法和归并排序一点关系都没有。

操作思路如下：

new_t = t1.val + t2.val

new_t.left = t1.left.val + t2.left.val

new_t.right = t1.right.val + t2.right.val

加上递归后有一些问题需要考虑到

- merge()函数的输入是t1 和 t2，输出是new Tree t, t的子节点通过递归操作生成
- 需要考虑到各种None的情况

new_t = t1.val + t2.val

new_t.left = merge(t1.left, t2.left)

new_t.right = merge(t1.right, t2.right)

```
class Solution(object):
    def mergeTrees(self, t1, t2):
        """
        :type t1: TreeNode
        :type t2: TreeNode
        :rtype: TreeNode
        """
        if t1 == None and t2 == None:
            return None
        if t1 == None and t2 != None:
            return t2
        if t1 != None and t2 == None:
            return t1
        t = TreeNode(t1.val + t2.val)
        t.left = self.mergeTrees(t1.left, t2.left)
        t.right = self.mergeTrees(t1.right, t2.right)
        return t
```
### 6.判断路径和是否等于一个数

[112\. Path Sum (Easy)](https://leetcode.com/problems/path-sum/description/)

当node没有子节点，并且自己的val等于sum的时候，我们就可以判断True了

```
class Solution(object):
    def hasPathSum(self, root, sum):
        """
        :type root: TreeNode
        :type sum: int
        :rtype: bool
        """
        if not root:
            return False
        if root.left == None and root.right == None and root.val == sum:
            return True
        return self.hasPathSum(root.left, sum - root.val) or self.hasPathSum(root.right, sum - root.val)
```

### 7.判断路径和是否等于一个数III

[437\. Path Sum III (Easy)](https://leetcode.com/problems/path-sum-iii/description/)

路径可以不以根节点开始，也可以不以叶节点结尾，中间任何一段都可以。那么我们可以推出递归公式

res = root的res + root.left的res + root.right的res

其中root.left 和 root.right的结构和root一样，可以都用pathSum来求解，所以我们需要单独写一个helper来计算从root开始的res，这个和上一题就一样了

```
class Solution(object):
    def pathSum(self, root, sum):
        """
        :type root: TreeNode
        :type sum: int
        :rtype: int
        """
        if not root:
            return 0
        res = self.helper(root, sum) + self.pathSum(root.left, sum) + self.pathSum(root.right, sum)
        return res
    
    def helper(self, root, Sum):
        if not root:
            return 0
        res = 0
        if root.val == Sum:
            res += 1
        res += self.helper(root.left, Sum-root.val) + self.helper(root.right, Sum-root.val)
        return res
```

### 8.判断是否为子树

[572\. Subtree of Another Tree (Easy)](https://leetcode.com/problems/subtree-of-another-tree/description/)

这题的思路和上一题一样，先找递归公式：

res = helper(s,t) or main(s.left,t) or main(s.right, t)

其中helper写法稍有不同，分为三种情况讨论：1.s和t都为空；2.s或者t有一个为空；3.t和t都不为空。

注意：在判断s和t是否相等时候，只能使用s.val != t.val --> False 因为当s.val == t.val的时候，也有可能是False（可能他们的子节点不同）

```
class Solution(object):
    def isSubtree(self, s, t):
        """
        :type s: TreeNode
        :type t: TreeNode
        :rtype: bool
        """
        if not s:
            return False
        res = self.helper(s, t) or self.isSubtree(s.left, t) or self.isSubtree(s.right, t)
        return res
    
    def helper(self, s, t):
        if s == None and t == None:
            return True
        if s == None or t == None:
            return False
        if s.val != t.val:
            return False
        return self.helper(s.left, t.left) and self.helper(s.right, t.right)
```

### 9.判断树是否对称

[101\. Symmetric Tree (Easy)](https://leetcode.com/problems/symmetric-tree/description/)

思路与上一题如出一辙，不再赘述

```
class Solution(object):
    def isSymmetric(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        if not root:
            return True
        res = self.helper(root.left, root.right)
        return res
    
    def helper(self, left, right):
        if left == None and right == None:
            return True
        if left == None or right == None:
            return False
        if left.val != right.val:
            return False
        return self.helper(left.left, right.right) and self.helper(left.right, right.left)
```

除此之外，递归的本质是Stack，所以我们可以自己写一个迭代的Stack来实现它。

```
class Solution2:
  def isSymmetric(self, root):
    if root is None:
      return True

    stack = [[root.left, root.right]]

    while len(stack) > 0:
      pair = stack.pop(0)
      left = pair[0]
      right = pair[1]

      if left is None and right is None:
        continue
      if left is None or right is None:
        return False
      if left.val == right.val:
        stack.insert(0, [left.left, right.right])

        stack.insert(0, [left.right, right.left])
      else:
        return False
    return True
```

### 10.计算树的最小深度

[111\. Minimum Depth of Binary Tree (Easy)](https://leetcode.com/problems/minimum-depth-of-binary-tree/description/)

最大深度我们已经做过了，思路是类似的，一个取left和right的最大值，一个取left和right的最小值。

```
class Solution(object):
    def minDepth(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        if not root:
            return 0
        left = self.minDepth(root.left)
        right = self.minDepth(root.right)
        if left == 0 or right == 0:
            return left + right + 1
        return min(left, right) + 1
```
