---
layout:     post
title:      关于LeetCode的一些关于递归方法的解答
subtitle:   算法
date:       2018-12-14
author:     Hybot
header-img: img/post-md.jpg
catalog: true
tags:
    - 算法
---

> 树是一种递归结构，很多树的问题可以使用递归来处理。

### 1.树的高度

[104\. Maximum Depth of Binary Tree (Easy)](https://leetcode.com/problems/maximum-depth-of-binary-tree/description/)

```
class Solution(object):
    def maxDepth(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        if not root:
            return 0
        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1
```

### 2.判断平衡树

[110\. Balanced Binary Tree (Easy)](https://leetcode.com/problems/balanced-binary-tree/description/)

判断左右子节点的深度差，大于1则为False

```
class Solution(object):
    def isBalanced(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        if not root:
            return True
        self.res = True
        self.helper(root)
        return self.res
        
    def helper(self, root):
        if not root:
            return 0
        l = self.maxDepth(root.left)
        r = self.maxDepth(root.right)
        if abs(l-r)>1:
            self.res = False
        self.helper(root.left)
        self.helper(root.right)
        
    def maxDepth(self, root):
        if not root:
            return 0
        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1
```

这种写法在树非常非常深的时候，会Time Limit Exceeded，主要耗时步骤就在maxDepth，我们并不需要得到所有子节点的深度，一旦深度差大于1，我们就可以return False了

```
class Solution(object):
    def isBalanced(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        if not root:
            return True
        self.res = True
        self.helper(root)
        return self.res
        
    def helper(self, root):
        if not root:
            return 0
        l = self.helper(root.left)
        r = self.helper(root.right)
        if abs(l-r)>1:
            self.res = False
        return max(l, r) + 1
```

### 3.树的直径求解

[543\. Diameter of Binary Tree (Easy)](https://leetcode.com/problems/diameter-of-binary-tree/description/)

root的直径 = root.left的深度 + root.right的深度

```
class Solution(object):
    def diameterOfBinaryTree(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        res = 0
        if not root:
            return res
        res = self.maxDepth(root.left) + self.maxDepth(root.right)
        return max(res, self.diameterOfBinaryTree(root.left), self.diameterOfBinaryTree(root.right))
        
    def maxDepth(self, root):
        if not root:
            return 0
        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1
```

发现这种方法非常耗时，和上一题一样，我们可以把对子节点深度的操作集成到maxDepth中去

在需要对子节点进行操作的问题中，我们一般把递归集成到maxDepth中，在maxDepth递归求解深度的过程中完成我们需要的答案求解。

```
class Solution(object):
    def diameterOfBinaryTree(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        self.res = 0
        if not root:
            return 0
        self.maxDepth(root)
        return self.res
        
    def maxDepth(self, root):
        if not root:
            return 0
        l = self.maxDepth(root.left)
        r = self.maxDepth(root.right)
        self.res = max(self.res, l+r)
        return max(l, r) + 1
```

### 4.翻转树操作

[226\. Invert Binary Tree (Easy)](https://leetcode.com/problems/invert-binary-tree/description/)

This problem was inspired by [this original twitter](https://twitter.com/mxcl/status/608682016205344768) by [Max Howell](https://twitter.com/mxcl):
> Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so fck off.

和树的深度求解一样简单的递归：(**弄明白递归函数的输入是什么，需要返回什么，什么时候跳出是写出递归的关键**)
left = root.left
root.left = root.right
root.right = left
变成递归模式，我们的left和right子节点也需要进行翻转操作
left = root.left
root.left = invert(root.right)
root.right = invert(left)

```
class Solution(object):
    def invertTree(self, root):
        """
        :type root: TreeNode
        :rtype: TreeNode
        """
        if not root:
            return None
        left = root.left
        root.left = self.invertTree(root.right)
        root.right = self.invertTree(left)
        return root
```

### 5.归并两颗树

[617\. Merge Two Binary Trees (Easy)](https://leetcode.com/problems/merge-two-binary-trees/description/)

归并排序会不会？不会赶快去复习复习十大排序算法，虽然这题解法和归并排序一点关系都没有。

操作思路如下：
new_t = t1.val + t2.val
new_t.left = t1.left.val + t2.left.val
new_t.right = t1.right.val + t2.right.val

加上递归后有一些问题需要考虑到

- merge()函数的输入是t1 和 t2，输出是new Tree t, t的子节点通过递归操作生成
- 需要考虑到各种None的情况

new_t = t1.val + t2.val
new_t.left = merge(t1.left, t2.left)
new_t.right = merge(t1.right, t2.right)

```
class Solution(object):
    def mergeTrees(self, t1, t2):
        """
        :type t1: TreeNode
        :type t2: TreeNode
        :rtype: TreeNode
        """
        if t1 == None and t2 == None:
            return None
        if t1 == None and t2 != None:
            return t2
        if t1 != None and t2 == None:
            return t1
        t = TreeNode(t1.val + t2.val)
        t.left = self.mergeTrees(t1.left, t2.left)
        t.right = self.mergeTrees(t1.right, t2.right)
        return t
```
### 6.判断路径和是否等于一个数

[Leetcdoe : 112\. Path Sum (Easy)](https://leetcode.com/problems/path-sum/description/)

当node没有子节点，并且自己的val等于sum的时候，我们就可以判断True了

```
class Solution(object):
    def hasPathSum(self, root, sum):
        """
        :type root: TreeNode
        :type sum: int
        :rtype: bool
        """
        if not root:
            return False
        if root.left == None and root.right == None and root.val == sum:
            return True
        return self.hasPathSum(root.left, sum - root.val) or self.hasPathSum(root.right, sum - root.val)
```
